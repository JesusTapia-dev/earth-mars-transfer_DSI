
"""
02_single_objective_optimization.py

Single-objective optimization prototype for Earth->Mars transfer:
- Decision variables: departure date (days offset) and time of flight (days)
- Objective: minimize total Delta-V (heliocentric impulsive estimate)
- Method: Genetic Algorithm via DEAP

Run:
    python 02_single_objective_optimization.py --help

Note:
- Requires internet on first Skyfield run to download ephemeris (de421.bsp).
"""

import argparse
import math
import random
from datetime import datetime, timedelta

import numpy as np
from deap import base, creator, tools, algorithms

from skyfield.api import load
from earth_mars_transfer import run_transfer

# --------- Configurable search window (edit to taste) ---------
# We'll center a window around a plausible Earth->Mars opportunity.
# Default: Aug 1, 2026 to Feb 1, 2029
START_DATE = datetime(2026, 8, 1)
END_DATE   = datetime(2029, 2, 1)

# Time of flight bounds (days)
TOF_MIN = 140.0
TOF_MAX = 320.0

# --------------------------------------------------------------

def clamp(x, lo, hi):
    return max(lo, min(hi, x))

def decode_individual(ind):
    """Decode individual -> (departure_datetime, arrival_datetime)."""
    dep_offset_days = ind[0]
    tof_days = ind[1]
    dep_date = START_DATE + timedelta(days=dep_offset_days)
    arr_date = dep_date + timedelta(days=tof_days)
    return dep_date, arr_date

def objective(individual, ts, planets):
    """Objective: minimize total DV. Apply soft penalties for out-of-bounds."""
    dep_offset, tof_days = individual

    # Bounds check + soft penalty
    penalty = 0.0
    if dep_offset < 0:
        penalty += (0 - dep_offset)**2
    if dep_offset > (END_DATE - START_DATE).days:
        penalty += (dep_offset - (END_DATE - START_DATE).days)**2
    if tof_days < TOF_MIN:
        penalty += (TOF_MIN - tof_days)**2
    if tof_days > TOF_MAX:
        penalty += (tof_days - TOF_MAX)**2

    dep_dt, arr_dt = decode_individual(individual)
    dep_tuple = (dep_dt.year, dep_dt.month, dep_dt.day, dep_dt.hour, dep_dt.minute, dep_dt.second)
    arr_tuple = (arr_dt.year, arr_dt.month, arr_dt.day, arr_dt.hour, arr_dt.minute, arr_dt.second)

    try:
        res = run_transfer(ts, planets, dep_tuple, arr_tuple)
        dv_total = res['dv_total']
    except Exception as e:
        # If Lambert fails or ephemeris issue, return large penalty
        dv_total = 1e6
        penalty += 1e5

    # Combine objective and penalty
    return (dv_total + penalty,)

def setup_deap(seed=42):
    random.seed(seed)
    np.random.seed(seed)

    # Fitness and Individual
    if 'FitnessMin' not in creator.__dict__:
        creator.create('FitnessMin', base.Fitness, weights=(-1.0,))
    if 'Individual' not in creator.__dict__:
        creator.create('Individual', list, fitness=creator.FitnessMin)

    toolbox = base.Toolbox()

    # Decision variables:
    #   x0: departure offset in days (0 .. window_days)
    #   x1: time of flight days (TOF_MIN .. TOF_MAX)
    window_days = (END_DATE - START_DATE).days

    toolbox.register('attr_dep', random.uniform, 0.0, float(window_days))
    toolbox.register('attr_tof', random.uniform, TOF_MIN, TOF_MAX)
    toolbox.register('individual', tools.initCycle, creator.Individual,
                     (toolbox.attr_dep, toolbox.attr_tof), n=1)
    toolbox.register('population', tools.initRepeat, list, toolbox.individual)

    # Ephemeris context shared across evaluations
    ts = load.timescale()
    planets = load('de421.bsp')
    toolbox.register('evaluate', objective, ts=ts, planets=planets)

    # Genetic operators
    toolbox.register('mate', tools.cxBlend, alpha=0.5)
    toolbox.register('mutate', tools.mutGaussian, mu=0.0, sigma=15.0, indpb=0.5)
    toolbox.register('select', tools.selTournament, tournsize=3)

    # Custom repair to keep individuals within bounds post-operators
    def repair(ind):
        window_days = (END_DATE - START_DATE).days
        ind[0] = clamp(ind[0], 0.0, float(window_days))
        ind[1] = clamp(ind[1], TOF_MIN, TOF_MAX)
        return ind

    toolbox.register('repair', repair)
    return toolbox

#def main(pop_size=30, ngen=20, cxpb=0.7, mutpb=0.3, seed=42, halloffame_k=5, verbose=True):
#    toolbox = setup_deap(seed=seed)
#    pop = toolbox.population(n=pop_size)
#    hof = tools.HallOfFame(halloffame_k)
#
#    stats = tools.Statistics(lambda ind: ind.fitness.values[0])
#    stats.register("min", np.min)
#    stats.register("avg", np.mean)
#    stats.register("std", np.std)
#
#    # Wrap evaluation to auto-repair
#    def evaluate_and_repair(individual):
#        toolbox.repair(individual)
#        return toolbox.evaluate(individual)
#
#    # Use built-in simple EA
#    algorithms.eaSimple(pop, toolbox, cxpb=cxpb, mutpb=mutpb,
#                        ngen=ngen, stats=stats, halloffame=hof, verbose=verbose,
#                        evalfunc=evaluate_and_repair)
#
#    # Decode best
#    best = hof[0]
#    dep_dt, arr_dt = decode_individual(best)
#    window_days = (END_DATE - START_DATE).days
#    result = {
#        "best_individual": best,
#        "best_fitness": best.fitness.values[0],
#        "best_departure": dep_dt.isoformat(),
#        "best_arrival": arr_dt.isoformat(),
#        "dep_offset_days": float(best[0]),
#        "tof_days": float(best[1]),
#        "window_days": window_days,
#    }
#
#    # Pretty print
#    print("\n=== Optimization Result ===")
#    for k, v in result.items():
#        print(f"{k}: {v}")
#
#    return result

def main(pop_size=30, ngen=20, cxpb=0.7, mutpb=0.3, seed=42, halloffame_k=5, verbose=True):
    toolbox = setup_deap(seed=seed)
    pop = toolbox.population(n=pop_size)
    hof = tools.HallOfFame(halloffame_k)

    stats = tools.Statistics(lambda ind: ind.fitness.values[0])
    stats.register("min", np.min)
    stats.register("avg", np.mean)
    stats.register("std", np.std)

    # Wrap evaluation to include repair
    def evaluate_and_repair(individual):
        toolbox.repair(individual)
        return toolbox.evaluate(individual)

    toolbox.register("evaluate_wrapped", evaluate_and_repair)

    # Run evolution using DEAP’s evaluate function override
    algorithms.eaSimple(pop, toolbox,
                        cxpb=cxpb,
                        mutpb=mutpb,
                        ngen=ngen,
                        stats=stats,
                        halloffame=hof,
                        verbose=verbose)

    # Decode best solution
    best = hof[0]
    dep_dt, arr_dt = decode_individual(best)
    result = {
        "best_individual": best,
        "best_fitness": best.fitness.values[0],
        "best_departure": dep_dt.isoformat(),
        "best_arrival": arr_dt.isoformat(),
        "dep_offset_days": float(best[0]),
        "tof_days": float(best[1]),
    }

    print("\n=== Optimization Result ===")
    for k, v in result.items():
        print(f"{k}: {v}")

    return result




if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Single-objective ΔV minimization for Earth->Mars transfer (GA/DEAP).")
    parser.add_argument("--pop", type=int, default=6, help="Population size")
    parser.add_argument("--gen", type=int, default=2, help="Number of generations")
    parser.add_argument("--cxpb", type=float, default=0.7, help="Crossover probability")
    parser.add_argument("--mutpb", type=float, default=0.3, help="Mutation probability")
    parser.add_argument("--seed", type=int, default=42, help="Random seed")
    args = parser.parse_args()

    main(pop_size=args.pop, ngen=args.gen, cxpb=args.cxpb, mutpb=args.mutpb, seed=args.seed, verbose=True)
